# üìë DOSSIER DE RECHERCHE & D√âVELOPPEMENT : PROJECT "EVOLENIA" v2.0
> *R√©vision scientifique compl√®te ‚Äî Corrections des lacunes formelles de la v1.0*

---

## 1. Vision et Objectifs Scientifiques

**EvoLenia** est un √©cosyst√®me de vie artificielle (ALife) o√π l'√©volution est **endog√®ne** (interne au syst√®me), impl√©ment√© en Rust natif avec WGPU.

- **But** : Observer l'√©mergence spontan√©e de taxinomies (esp√®ces) num√©riques **mesurables**.
- **Innovation** : Contrairement √† Lenia classique (1 r√®gle globale), chaque pixel poss√®de son propre **g√©nome dynamique √† 5 canaux** cod√© dans une texture GPU, avec un op√©rateur d'advection garantissant la **conservation de masse**.
- **Moteur** : Physique continue (Fluide + Conservation) + G√©n√©tique discr√®te (Mutations).

### 1.1 Positionnement par rapport √† l'√©tat de l'art

| Feature                      | Lenia (Chan 2019) | Flow-Lenia (2025) | **EvoLenia v2 (ce projet)** |
|------------------------------|:-----------------:|:-----------------:|:---------------------------:|
| R√®gles globales               | ‚úÖ                | ‚úÖ                | ‚úÖ                          |
| G√©nome spatialis√©             | ‚ùå                | ‚úÖ                | ‚úÖ                          |
| **Conservation de masse**     | ‚ùå                | ‚úÖ                | ‚úÖ (corrig√©)                |
| **Advection ADN (s√©gr√©g√©e)**  | N/A               | Partielle         | ‚úÖ (novateur)               |
| Mutations endog√®nes           | ‚ùå                | ‚úÖ                | ‚úÖ                          |
| **Pr√©dation explicite**       | ‚ùå                | ‚ùå                | ‚úÖ (novateur)               |
| GPU natif (WGPU/Rust)         | ‚ùå                | ‚ùå (JAX/Python)   | ‚úÖ (avantage comp√©titif)    |
| **M√©triques d'√©mergence**     | ‚ùå                | Partielle         | ‚úÖ (corrig√©)                |

> **R√©f√©rence principale** : *Flow-Lenia: Emergent Evolutionary Dynamics in Mass Conservative Lenia*, Artificial Life, MIT Press, 2025.

---

## 2. Stack Technique

| Composant        | Technologie                     | Justification                                                          |
|------------------|---------------------------------|------------------------------------------------------------------------|
| Langage          | **Rust** (edition 2021)         | S√ªret√© m√©moire sans GC ‚Üí d√©terminisme des simulations                  |
| Backend Calcul   | **WGPU v22+** (WGSL)            | Multi-API (Vulkan, Metal, DX12, WebGPU) ‚Üí reproductibilit√©             |
| Architecture     | **Data-Oriented Design**        | Cache-friendly ‚Üí throughput maximal pour des millions de pixels-agents |
| Parall√©lisme     | **SIMD massif GPU**             | Chaque pixel = 1 thread ind√©pendant                                    |
| Buffering        | **Ping-Pong Buffers (√ó2)**      | √âvite les race conditions ‚Üí r√©sultats d√©terministes                    |
| Fen√™trage        | **winit**                       | Cross-platform window management                                       |
| M√©triques        | **R√©ductions GPU (atomics)**    | Calcul en-place de la diversit√© g√©nomique sans transfert CPU           |

---

## 3. Les Lois de l'Univers EvoLenia (Formalisme Math√©matique Complet)

### 3.1 La Pentade des Champs (Textures 2D)

> ‚ö†Ô∏è **Correction v2** : Le g√©nome passe de 4 √† **5 canaux** (`vec4` + buffer s√©par√© ou packing). Les canaux `mu` et `sigma` sont **obligatoires** pour la fonction de croissance de Lenia.

| Champ   | Type           | Description                                         | Plage    |
|---------|----------------|-----------------------------------------------------|----------|
| `M`     | `f32`          | **Masse** : Densit√© de "mati√®re" de la cr√©ature     | [0, 1]   |
| `E`     | `f32`          | **√ânergie** : R√©serve m√©tabolique                   | [0, 1]   |
| `G.r`   | `f32` (Genome) | **Rayon de perception** `r` (morphologie)           | [2, 16]  |
| `G.g`   | `f32` (Genome) | **Centre de croissance** `Œº` (niche √©cologique)     | [0, 1]   |
| `G.b`   | `f32` (Genome) | **Largeur de croissance** `œÉ` (tol√©rance)           | [0.01, 0.3] |
| `G.a`   | `f32` (Genome) | **Agressivit√©** (pr√©dation)                         | [0, 1]   |
| `G2.r`  | `f32` (Genome) | **Taux de mutation** (instabilit√© g√©n√©tique)        | [0, 0.1] |

> Les 5 g√®nes sont stock√©s dans **deux textures RGBA** : `genome_a` (`r, Œº, œÉ, agressivit√©`) et `genome_b.r` (`mutation_rate`).

### 3.2 Formalisme Math√©matique de Lenia (Complet)

La r√®gle de Lenia est d√©finie par :

```
U(x, t) = (K_r * M)(x, t)          // Convolution avec noyau K de rayon r
G(u; Œº, œÉ) = exp(-((u - Œº)¬≤ / (2œÉ¬≤)))  // Fonction de croissance (cloche gaussienne)
ŒîM(x, t)  = 2¬∑G(U(x,t); Œº(x), œÉ(x)) - 1  // Incr√©ment de masse ‚àà [-1, +1]
M(x, t+dt) = clamp(M(x,t) + dt ¬∑ ŒîM(x,t), 0, 1)
```

**Le noyau normalis√©** (ring kernel de Lenia) :

```
K_r(x) = (1/Z) ¬∑ exp(-((|x|/r - 0.5)¬≤ / (2¬∑0.15¬≤)))
Z = Œ£_x K_r(x)    // Facteur de normalisation (somme = 1)
```

> ‚ö†Ô∏è **Correction v2** : Le noyau DOIT √™tre normalis√© (`Z`). Sans normalisation, `U` sort de [0,1] et la fonction de croissance diverge.

### 3.3 Conservation de la Masse (Op√©rateur d'Advection)

> ‚ö†Ô∏è **Correction critique v2** : La masse doit √™tre **transf√©r√©e**, jamais copi√©e.

L'advection est calcul√©e via un **champ de vitesse local** `v(x,t)` d√©riv√© du gradient de masse :

```
v(x, t) = ‚àáM(x, t) ¬∑ aggressivity(x)  // Pr√©dateurs "remontent" le gradient

// Conservation : flux entrant = flux sortant
M_new(x) = M(x) + Œ£_{n ‚àà voisins} flux(n ‚Üí x) - Œ£_{n ‚àà voisins} flux(x ‚Üí n)

// flux(x ‚Üí n) = clamp(v(x,t) ¬∑ dir(x‚Üín), 0, M(x)/4)
// Limiteur : on ne peut pas transf√©rer plus de M(x)/4 vers un voisin
```

**V√©rification de conservation** (√† chaque step sur le CPU, en debug) :

```
assert(|Œ£_x M_new(x) - Œ£_x M(x)| < Œµ)  // Œµ = 1e-4
```

### 3.4 Le M√©tabolisme Corrig√©

```
cost(x) = length(vec3(Œº, œÉ, aggressivity)) ¬∑ M(x) ¬∑ 0.01
         // P√©nalise la complexit√© g√©nomique (parcimonie de Darwin)

absorption(x) = ResourceMap(x) ¬∑ M(x) ¬∑ 0.05
               // ResourceMap : nutriments locaux (dynamique, voir ¬ß3.6)

E_new(x) = clamp(E(x) + absorption(x) - cost(x), 0, 1)
```

### 3.5 La Pr√©dation (M√©canisme Corrig√©)

> ‚ö†Ô∏è **Correction v2** : La pr√©dation op√®re via le **champ de flux**, pas par transfert direct.

```
// Un pr√©dateur (G.a √©lev√©) oriente son flux vers les voisins √† M faible
predation_flux(x ‚Üí n) = G.a(x) ¬∑ clamp(M(x) - M(n), 0, ‚àû) ¬∑ 0.02
                       // Ne vole que si M(x) > M(n) (force du plus fort)

// Co√ªt m√©tabolique de la pr√©dation
E(x) -= predation_flux_total(x) ¬∑ 0.1  // La pr√©dation co√ªte de l'√©nergie
```

### 3.6 La ResourceMap Dynamique

> ‚ö†Ô∏è **Correction v2** : La ResourceMap doit √™tre **dynamique** pour cr√©er une pression s√©lective spatiale.

```
// R√©action-Diffusion de type Gray-Scott pour les nutriments
R_new(x) = R(x) + D_R ¬∑ ‚àá¬≤R(x) + feed_rate ¬∑ (1 - R(x)) - R(x) ¬∑ M(x) ¬∑ consumption
         // R(x) ‚àà [0,1] : concentration de nutriment
         // D_R = 0.1 : coefficient de diffusion
         // feed_rate = 0.04 : taux de r√©g√©n√©ration
```

### 3.7 H√©r√©dit√© & Advection ADN (S√©gr√©gation G√©nomique)

> ‚ö†Ô∏è **Correction critique v2** : L'advection ADN ne doit PAS √™tre une moyenne (convergence g√©nomique). Utiliser la **s√©gr√©gation stochastique** :

```
// Lors du transfert de masse flux(x ‚Üí n) :
// La masse "emporte" son ADN stochastiquement, pas en moyenne

if (flux > threshold) {
    // Le g√©nome du receveur est remplac√© avec probabilit√© proportionnelle au flux
    p_replace = flux / (M(n) + flux)
    if (random() < p_replace) {
        G_new(n) = G(x)  // Le donneur "colonise" le receveur
    }
    // Sinon, G(n) est conserv√© (r√©sistance g√©nomique)
}
```

### 3.8 Mutations (Mod√®le Corrig√©)

> ‚ö†Ô∏è **Correction v2** : Le taux de mutation `A` doit avoir un prior pour √©viter la d√©rive vers 0 ou 1.

```
// Mutation avec prior b√™ta (Œ±=0.5, Œ≤=5.0) pour favoriser les faibles taux de mutation
noise = hash_prng(pos, frame_id) * 2.0 - 1.0  // ‚àà [-1, +1]

G_new.r     = clamp(G.r     + noise * mut_rate * 14.0,  2.0, 16.0)
G_new.mu    = clamp(G.mu    + noise * mut_rate,          0.0,  1.0)
G_new.sigma = clamp(G.sigma + noise * mut_rate * 0.3,   0.01,  0.3)
G_new.agg   = clamp(G.agg   + noise * mut_rate,          0.0,  1.0)

// Mutation du taux de mutation lui-m√™me (m√©ta-√©volution), avec prior
G_new.mut_rate = clamp(
    G.mut_rate + noise * 0.001,  // Pas petit pour la m√©ta-mutation
    0.0001,                       // Minimum : quasi-stable
    0.05                          // Maximum : jamais chaotique
)
```

---

## 4. Architecture GPU Compl√®te (WGPU Pipeline)

### 4.1 Buffers

```
WorldState {
    // Ping-Pong : current (read) / next (write)
    mass_current:     StorageBuffer<f32>[WIDTH * HEIGHT],
    mass_next:        StorageBuffer<f32>[WIDTH * HEIGHT],
    energy_current:   StorageBuffer<f32>[WIDTH * HEIGHT],
    energy_next:      StorageBuffer<f32>[WIDTH * HEIGHT],
    genome_a_current: StorageBuffer<vec4<f32>>[WIDTH * HEIGHT],  // r, mu, sigma, agg
    genome_a_next:    StorageBuffer<vec4<f32>>[WIDTH * HEIGHT],
    genome_b_current: StorageBuffer<f32>[WIDTH * HEIGHT],        // mut_rate
    genome_b_next:    StorageBuffer<f32>[WIDTH * HEIGHT],
    resource_map:     StorageBuffer<f32>[WIDTH * HEIGHT],        // Nutriments
    velocity_field:   StorageBuffer<vec2<f32>>[WIDTH * HEIGHT],  // Flux d'advection
}
```

### 4.2 Passes Compute (Ordre Obligatoire)

```
Frame N:
  Pass 1 : compute_velocity.wgsl    ‚Üí velocity_field (‚àáM, pr√©dation)
  Pass 2 : compute_evolution.wgsl   ‚Üí mass_next, energy_next, genome_a_next, genome_b_next
  Pass 3 : compute_resources.wgsl   ‚Üí resource_map (Gray-Scott)
  Pass 4 : normalize_mass.wgsl      ‚Üí correction conservation de masse (global reduction)
  Pass 5 : render.wgsl              ‚Üí framebuffer display
  Swap    : current ‚Üî next (ping-pong)
```

---

## 5. M√©triques d'√âmergence (Sans Transfert CPU)

> ‚ö†Ô∏è **Correction v2** : Sans m√©triques quantitatives, c'est de l'art g√©n√©ratif, pas de la science.

Les m√©triques suivantes sont calcul√©es **en GPU** via des passes de r√©duction atomique :

| M√©trique                  | Formule GPU                                        | Interpr√©tation                              |
|---------------------------|-----------------------------------------------------|---------------------------------------------|
| **Masse totale**          | `Œ£ M(x)`                                           | Conservation (doit √™tre constante)          |
| **Diversit√© g√©nomique**   | `H = -Œ£ p(g) ¬∑ log(p(g))` (Shannon sur G.mu/G.r)  | > 0 = coexistence de taxinomies             |
| **√ânergie moyenne**       | `<E>`                                              | Sant√© globale de l'√©cosyst√®me               |
| **Variance d'agressivit√©**| `Var(G.a)`                                         | Pr√©sence de la dynamique proie-pr√©dateur    |
| **Taille des cliques**    | Clustering spatial de G (r-voisinage uniforme)     | Taille des "colonies" d'esp√®ces             |

---

## 6. Rendu Visuel (Biomorph Rendering)

```wgsl
// Mapping couleur ‚Üí g√©notype visible
let species_color = vec3<f32>(
    genome_a.r / 16.0,   // R = rayon ‚Üí rouge (petites cr√©atures = rouge vif)
    genome_a.g,           // G = mu    ‚Üí vert  (niche √©cologique)
    genome_a.b            // B = sigma ‚Üí bleu  (tol√©rance/g√©n√©ralisme)
);
let alpha = mass;  // Opacit√© = densit√© de masse

// Surbrillance des pr√©dateurs (agressivit√© > 0.7 ‚Üí halo orange)
let predator_glow = step(0.7, genome_a.a) * vec3<f32>(1.0, 0.5, 0.0);
let final_color = species_color + predator_glow * 0.3;
```

---

## 7. üöÄ MASTER PROMPT CORRIG√â : "EVOLENIA RUST ENGINE v2"

```
Role: You are a World-Class Systems Architect and Artificial Life Researcher,
specializing in Rust, WGPU, and GPU-accelerated simulations.

Project Goal: Implement the "EvoLenia v2" engine ‚Äî a spatially-varying
continuous cellular automaton with endogenous evolution, mass conservation,
and emergent predation dynamics.

=== 1. Project Structure (Cargo.toml) ===
Dependencies:
  wgpu       = "22"
  winit      = "0.30"
  bytemuck   = { version = "1", features = ["derive"] }
  pollster   = "0.3"
  rand       = "0.8"
  env_logger = "0.11"

=== 2. Constants ===
  WORLD_WIDTH  : u32 = 1024
  WORLD_HEIGHT : u32 = 1024
  WORKGROUP_X  : u32 = 16
  WORKGROUP_Y  : u32 = 16
  DT           : f32 = 0.1

=== 3. Memory Layout (GPU Buffers) ===
Implement a WorldState struct holding, in PING-PONG pairs (current/next):
  - mass         : StorageBuffer<f32>          (1 float per pixel)
  - energy       : StorageBuffer<f32>          (1 float per pixel)
  - genome_a     : StorageBuffer<vec4<f32>>    (r, mu, sigma, aggressivity)
  - genome_b     : StorageBuffer<f32>          (mutation_rate only)
  - resource_map : StorageBuffer<f32>          (single buffer, updated in place)
  - velocity     : StorageBuffer<vec2<f32>>    (advection field, single buffer)
All buffers use STORAGE | COPY_SRC | COPY_DST usage flags.
Use bytemuck for zero-copy casting.

=== 4. Compute Shaders (WGSL) ‚Äî 4 separate .wgsl files ===

--- 4a. compute_velocity.wgsl ---
  Input  : mass_current, genome_a_current
  Output : velocity (vec2<f32> per pixel)
  Logic  :
    1. Compute gradient ‚àáM via central differences.
    2. Base velocity = ‚àáM (mass flows uphill for predators).
    3. Predation component: for each neighbor n,
       if aggressivity > 0.5 AND M(self) > M(n):
         flux_out += aggressivity * (M(self) - M(n)) * 0.02
         velocity oriented toward n
    4. velocity(x) = clamp(aggressivity * ‚àáM, -1.0, 1.0)

--- 4b. compute_evolution.wgsl ---
  Input  : mass_current, energy_current, genome_a_current, genome_b_current,
           resource_map, velocity
  Output : mass_next, energy_next, genome_a_next, genome_b_next
  Logic  :
  
  [PRNG]
  Implement hash-based PRNG: pcg_hash(state: u32) -> u32
  float_from_hash(h: u32) -> f32 (maps to [-1, +1])
  seed = hash(pixel_index XOR frame_id XOR 0xDEADBEEFu)

  [KERNEL BLENDING]
  Three pre-defined ring kernels for radii 3, 7, 14.
  Interpolate between kernels based on genome_a.r.
  Each kernel cell weight = exp(-((dist/r - 0.5)^2 / (2*0.15^2)))
  Normalize kernel (sum = 1.0) before use.

  [CONVOLUTION & GROWTH]
  U = sum over kernel window of kernel_weight * M(neighbor)
  G(U) = exp(-((U - genome_a.g)^2 / (2 * genome_a.b^2)))
  dM   = 2.0 * G(U) - 1.0
  mass_candidate = clamp(M + DT * dM, 0.0, 1.0)

  [METABOLISM]
  cost        = length(genome_a.gbg) * M * 0.01
  absorption  = resource_map(x) * M * 0.05
  energy_next = clamp(E + absorption - cost, 0.0, 1.0)
  if energy_next <= 0.0: mass_candidate *= 0.99  // entropie douce

  [MASS-CONSERVATIVE ADVECTION]
  For each of 4 cardinal neighbors n:
    flux(self‚Üín) = clamp(velocity ¬∑ dir(self‚Üín), 0.0, M/4.0)
    flux(n‚Üíself) = read from velocity of neighbor n (inward component)
  mass_next = mass_candidate
            + sum(flux_in from neighbors)
            - sum(flux_out to neighbors)
  mass_next = clamp(mass_next, 0.0, 1.0)

  [DNA ADVECTION ‚Äî STOCHASTIC SEGREGATION]
  For each neighbor n where flux(n‚Üíself) > 0.001:
    p_replace = flux(n‚Üíself) / (mass_next + 0.001)
    if random() < p_replace:
      genome_a_next = genome_a(n)  // colonisation
      genome_b_next = genome_b(n)
    // Else: g√©nome local conserv√©

  [MUTATION]
  noise = float_from_hash(seed) * genome_b (mut_rate)
  genome_a_next.r   = clamp(genome_a.r   + noise*14.0, 2.0, 16.0)
  genome_a_next.g   = clamp(genome_a.g   + noise,      0.0,  1.0)
  genome_a_next.b   = clamp(genome_a.b   + noise*0.3,  0.01, 0.3)
  genome_a_next.a   = clamp(genome_a.a   + noise,      0.0,  1.0)
  genome_b_next     = clamp(genome_b     + noise*0.01, 1e-4, 0.05)
  // Appliquer uniquement si mass_next > 0.01 (les cellules mortes ne mutent pas)

--- 4c. compute_resources.wgsl ---
  Input/Output : resource_map (in-place)
  Logic (Gray-Scott simplifi√©) :
    laplacian_R  = (R(up)+R(down)+R(left)+R(right) - 4*R(x)) / 4.0
    consumed     = R(x) * M(x) * 0.05
    R_new        = clamp(R(x) + 0.1*laplacian_R + 0.04*(1-R(x)) - consumed, 0, 1)

--- 4d. normalize_mass.wgsl ---
  Two-pass reduction:
    Pass A: each workgroup sums its local mass into a StorageBuffer<atomic<u32>>
            using atomicAdd (cast f32 to u32 bits for atomics).
    Pass B: single-thread corrects total:
            correction = TARGET_TOTAL_MASS / actual_total
            mass(x) *= correction  [clamp to [0,1]]
  TARGET_TOTAL_MASS = WORLD_WIDTH * WORLD_HEIGHT * 0.15  // 15% de remplissage initial

=== 5. Rendering Pipeline ===
Vertex shader  : full-screen quad (2 triangles, no vertex buffer).
Fragment shader:
  species_color = vec3(genome_a.r/16, genome_a.g, genome_a.b)
  predator_glow = step(0.7, genome_a.a) * vec3(1.0, 0.5, 0.0)
  final_color   = species_color + predator_glow * 0.3
  output_alpha  = mass
  // Utiliser la texture de masse et de g√©nome comme uniform textures (sampler2D)

=== 6. Initialization (CPU side, main.rs) ===
  Seed random clusters of 20‚Äì40 pixels (not uniform noise):
    - Random position, random radius 5‚Äì15
    - Genome values drawn from uniform distributions within valid ranges
    - Mass = gaussian falloff from center
    - Energy = 0.5 (uniform)
    - Resource map = 1.0 (full nutrients at start)
  Use at least 50 independent seed clusters.

=== 7. Metrics Collection (optional, CPU readback every 300 frames) ===
  - Copy mass_current to staging buffer
  - Compute on CPU: total_mass, mean_energy
  - Log to stderr as CSV: frame, total_mass, mean_energy
  - Allows verifying mass conservation over time

=== 8. Main Loop (main.rs) ===
  pollster::block_on(async {
    // init wgpu: instance, adapter, device, queue
    // init winit event loop
    // init WorldState and all pipelines
    // event loop:
    //   on RedrawRequested:
    //     run_compute_pass_1(velocity)
    //     run_compute_pass_2(evolution)
    //     run_compute_pass_3(resources)
    //     run_compute_pass_4(normalize)
    //     run_render_pass()
    //     swap ping-pong buffers
    //   on KeyboardInput(Escape): exit
  })

=== Deliverables ===
Provide:
  - Cargo.toml
  - src/main.rs          (WGPU init, pipeline creation, event loop)
  - src/world.rs         (WorldState struct, buffer management, swap)
  - src/shaders/compute_velocity.wgsl
  - src/shaders/compute_evolution.wgsl
  - src/shaders/compute_resources.wgsl
  - src/shaders/normalize_mass.wgsl
  - src/shaders/render.wgsl

=== Quality Requirements ===
  - All WGSL code must be valid WGSL 2024 (no GLSL-isms).
  - All kernel accesses must use wrapping modular indexing (toroidal world).
  - All random number generation must be hash-based (no global state).
  - All biological principles must be commented in the shader code.
  - Mass conservation must hold to within 0.01% per frame.
  - Code must compile with `cargo build --release` without warnings.
```

---

## 8. Crit√®res de Validation Scientifique

Pour que le projet soit consid√©r√© comme une **d√©monstration scientifique** (et non artistique), les ph√©nom√®nes suivants doivent √™tre observables et mesurables :

| Ph√©nom√®ne                  | Indicateur Mesurable                                      | Seuil de validation         |
|----------------------------|-----------------------------------------------------------|-----------------------------|
| Coexistence d'esp√®ces      | Entropie de Shannon sur G.mu > 1.5 bits                  | Apr√®s 10 000 frames         |
| S√©lection naturelle        | Corr√©lation n√©gative `co√ªt ~ survie`                      | p < 0.05 sur 100 runs       |
| Conservation de masse      | `|Œ£ M_t - Œ£ M_0| / Œ£ M_0 < 0.01%`                       | √Ä chaque frame              |
| Dynamique proie-pr√©dateur  | Oscillations de Lotka-Volterra dans `Var(G.a)` vs `<M>`  | P√©riode observable          |
| Diversification g√©nomique  | Augmentation de `Var(G)` dans le temps                   | Monotone sur 5000 frames    |

---

## 9. Glossaire Bio-Math√©matique

| Terme                 | D√©finition dans EvoLenia                                                      |
|-----------------------|-------------------------------------------------------------------------------|
| **Noyau `K_r`**       | Ring kernel de Lenia : d√©tecte la densit√© locale √† une distance ‚âà r/2        |
| **`U(x,t)`**          | Signal de densit√© per√ßu par la cellule (r√©sultat de la convolution)          |
| **`G(U; Œº, œÉ)`**      | Fonction de croissance en cloche : favorise les densit√©s autour de Œº         |
| **`ŒîM`**              | Incr√©ment de masse ‚àà [-1,+1] : positif = croissance, n√©gatif = dissipation   |
| **Advection ADN**     | Transport du g√©nome par le flux de masse (h√©r√©dit√© spatiale)                 |
| **S√©gr√©gation**       | D√©cision stochastique : le g√©nome d'une cellule "gagne" ou "r√©siste"         |
| **Prior b√™ta sur A**  | Distribution de probabilit√© qui √©vite que le taux de mutation d√©rive √† 0/1   |
| **Gray-Scott**        | Syst√®me de r√©action-diffusion mod√©lisant la dynamique des nutriments         |
| **Conservation**      | Propri√©t√© fondamentale : `Œ£ M` reste constant (ni cr√©ation ni destruction)   |